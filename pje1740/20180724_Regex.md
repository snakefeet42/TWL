# 2018년 7월 24일

## 파이썬 주요 라이브러리 링크

Python Crash Course cheat sheets

Pandas cheat sheet

Regular expression cheat sheet

구글에서 “cheatsheet” 키워드로 검색하기!!



## A/B 테스트

A와 B 둘 중 무엇이 더 효과적일까? 라는 방식의 테스트.

현업에선 다른 표현으로 RCT(Randomized Controlled Test)라고도 한다.



레이싱 게임의 예를 들면 다음처럼 이해할 수 있다:

1등과 꼴찌 사이의 골인 시간의 격차를 줄이면 1등을 하는 사람의 대기 시간을 줄일 수 있을 것이다. 그러면 사람들이 지루함을 덜 느끼고 게임을 이탈하는 일이 줄 것이다 -> 라는 추측을 한다. 

이를 알아보기 위해 플레이어들이 랜덤 맵 생성을 눌렀을 때, 다음의 알고리즘을 돌려본다.

잘하는 플레이어가 상대적으로 잘 못하는 맵 & 못하는 플레이어가 상대적으로 잘하는 맵

이렇게 했을 때 이 플레이어들의 플레이시간과 결제율을 확인해보면 가설을 확인해볼 수 있다. 



이런 알고리즘에 의한 랜덤 맵을 받은 플레이어 그룹과 정말 임의의 맵을 받은 플레이어들을 비교해보면 답이 나온다. 



이런 A/B test를 하기 위해선 다음의 두 가지를 지켜야 한다. 

1) Random Selection = 임의의 그룹을 뽑되 대표성이 있는 집단이어야 한다. 

2) Random Assignment = 집단에서 임의로 그룹을 뽑아서 차이를 줘본다. 



이런 테스트는 툴보다도 설계와 결과 해석이 중요하다.



## 국민청원 크롤링 복습

필요없는 스트링 삭제하는 명령어 compression

~~~
# 이 방식을
text = "..."
text = remove_e(text, "\t")
text = remove_e(text, "\n")
text = remove_e(text, "분류")

# 이렇게
text = "..."
for e in ["\t", "\n", "분류"]:
	text = remove_e(text)
~~~



**매직넘버**

무슨 의미인지 알 수 없지만 있으면 코드가 작동하고 없으면 작동 하지 않는 숫자(sarcasm).

나중에 돌아와서 보면 왜 이 숫자가 넣어졌는지 알 수 없음(이건 피하는 게 좋음)



## 정규표현식

콜랩 실습 링크:

https://colab.research.google.com/drive/1es6og2g-Lt4OuvAF4z9NAp9xwCr_B_gE#scrollTo=AkcblwEyVKAU



정규표현식 실습 사이트:

https://regex101.com/



정규표현식 구조 보기:

https://regexper.com/



### 표현식 익히기

정규표현식은 다양한 기호를 이용해 여러가지 의미를 내포한다. 

잊지말아야 할 점은 순서대로 읽힌다는 것이다. 



**일반문자열**

~~~
"문재인": 문 -> 재 -> 인
~~~



**메타캐릭터**

~~~
^ : 문장 맨 앞
$ : 문장 맨 뒤
. : 아무거나 한 글자
\d : 아무거나 한 숫자 = [0-9]
\D : 숫자가 아닌 어떠한 한 글자
\s : 공백 한 글자 (공백을 지우기 위해 이를 이용할 수 있다)
\S : 공백이 아닌 한 글자
~~~



**이스케이프**

~~~
\
역슬래시는 메타캐릭터를 다시 모양 그대로의 문자로 읽기 위해 사용된다. 

"\$500" : $500
"\^\^" : ^^

주의할 점은, 파이썬은 이미 역슬래시 자체가 내포하는 의미가 있기 때문에 \\와 같이 두번 써주어야 동일한 작동을 한다. 
이런 이유로 파이썬에선 정규표현식 앞에 r을 붙여서 이런 불편을 간소화해준다. 
~~~



**캐릭터 클래스**

~~~
"[초중고]3" : (초 or 중 or 고) -> 3
"[1-3]" : 1부터 3까지 하나
"[중고][1-3] : (중 or 고) -> (1 or 2 or 3)

얼터레이션
"(존경|친애)하옵?는" : (존경 or 친애)하+(옵이 있거나 없거나)+는
~~~



**양화사(quantifier)**

~~~
? : 있으면 찾고 없으면 스킵.
* : 0개 이상
+ : 1개 이상
{숫자} : 앞에 나오는 것을 괄호 안의 숫자만큼 찾는다.
~~~



**Non-greedy Quantifier**

정규표현식에서 + 와 *는 최대한 많이 찾는다는 규칙이 있다. 그래서 문제가 되는 경우가 있는데, 이는 다음과 같다. 

~~~
.+?\.

이것을 해석하면:
(아무거나 한 글자)가 1개 이상 계속 나오다가 온점(.)을 발견하면 멈춘다.

그러나 온점 또한 (아무거나 한 글자)에 해당되기 때문에 다음 같은 문장에서 문제가 발생한다.

"안녕하세요. 반갑습니다."

의도는 "안녕하세요."만 찾는 것이었을지라도 온점도 아무 글자로 인식되면서 "안녕하세요. 반갑습니다."를 찾게 된다. 이 때 취할 수 있는 방법이 다음과 같다. 

+?
*?

뒤에 물음표를 붙이면 원래의 '최대한 많이' 규칙 대신 최소한으로 찾게된다.  
~~~



### 정규표현식을 이용한 예시들



**휴대폰 번호에 국가번호 추가하기**

~~~
import re

text1 = "어쩌고 019-1234-5678, 저쩌고 010-2345-6789"
re.sub(r'01(\d)-(\d{4})-(\d{4})', r'+82-1\1-\2-\3', text1)
~~~

위는 핸드폰 번호 형태의 데이터를 찾아서 국가번호까지 추가한 형태로 바꿔주는 코드다. 

괄호로 묶인 정규표현식은 그룹으로 인식이 된다. \1은 첫 괄호 묶음, \2는 두번째 괄호 묶음으로 이해하면 된다. 

위를 해석해보면:



01(숫자) - (숫자 네개) - (숫자 네개) 형태인 것을 찾아서

+82 - 1(그룹1번) - (그룹2번) - (그룹3번)

로 바꾼다는 의미다.



**이메일 뽑아내기**

~~~
다음은 이메일 형태의 텍스트를 찾는 정규표현식이다.

\w[\w+.]*@\w+\.\w+(\.\w+)*

해석:

문자or숫자가 하나 먼저 나오고
(문자or숫자, 온점)이 0개 이상 나오고
@
문자or숫자가 1개 이상 나오고
온점이 나오고
문자or숫자가 1개 이상 나오고
(온점, 문자or숫자 1개 이상)이 0개 이상 나오면

~~~



**특정 내용 찾아내기**

수업에선 계속해서 국민청원을 이용해서 필요한 데이터를 뽑아내는 일을 실습해보고 있다. 

그 중'손해'를 언급하는 글은 무엇이 있을까? 그리고 이들은 얼마의 금액을 언급하고 있을까?

다음은 그것을 찾아내는 정규표현식이다.

~~~
\b[1-9]\d{0,2}(,\d{3})*원.+손해
~~~

이렇게 정규표현식으로 작업을 할 때 중요한 건 이 식이 필요한 형태의 텍스트만 인식해야한다는 점이다. 

그렇기 때문에 만약 손해를 언급하는 글을 추적하고 싶다면 미리 내가 찾고자 하는 것과 오류가 될 수 있는 형태를 구분하여 작성해보고 시작하면 좋다. 

~~~
Should Match:

나는 5,000원을 손해봤다. 
나는 5원을 손해봤다.
나는 50원을 손해봤다.

Should not Match:

나는 삼각형, 사각형, 원을 손해봤다. 
나는 삼각형, 비타5,원을 손해봤다. 
5,00원을 손해봤다
~~~

이렇게 미리 작성해두고 작업하면서 또 예상치 못한 형태의 텍스트는 추가해가면서 작업해보자. 